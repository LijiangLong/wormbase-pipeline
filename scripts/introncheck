#!/usr/local/bin/perl -w
#
# introncheck
# v 0.1
#
# Cronjob integrity check controls for generic ACEDB database.
#
# Usage: introncheck [-options]
#

#####################################################################################################


#################################################################################
# variables                                                                     #
#################################################################################

$|=1;
BEGIN {
  unshift (@INC,"/nfs/disk92/PerlSource/Bioperl/Releases/bioperl-0.05");
}
use Bio::Seq;
use IO::Handle;
use Getopt::Std;
use Cwd;
use Ace;
require "/wormsrv2/scripts/babel.pl";

 ##############################
 # Script variables (run)     #
 ##############################

my $maintainer = "dl1\@sanger.ac.uk, kj2\@sanger.ac.uk";
my $rundate = `date +%y%m%d`; chomp $rundate;
my $runtime = `date +%H:%M:%S`; chomp $runtime;

 ##############################
 # command-line options       #
 ##############################

$opt_d="";   # Verbose debug mode
$opt_h="";   # Help/Usage page
$opt_s="";   # check Status tags

getopts ('hd');
&usage(0) if ($opt_h);
my $debug = $opt_d;

 ##############################
 # Paths etc                  #
 ##############################

my $tace = glob("~acedb/RELEASE.DEVELOPMENT/bin.ALPHA_4/tace");    # tace executable path
my $dbdir  = "/wormsrv2/autoace";                                  # Database path
my $gffdir = "/wormsrv2/autoace/GFF_SPLITS";

#my @chromosomes = ('I');0
my @chromosomes = ('I','II','III','IV', 'V','X');
my %confirmed_intron = ();		  

 ########################################
 # Open logfile                         #
 ########################################

my $log="/wormsrv2/logs/introncheck.$rundate";

#open (LOG,">$log");
#LOG->autoflush();

 ########################################
 # Connect with acedb server            #
 ########################################

my $db = Ace->connect(-path=>$dbdir);


foreach $chromosome (@chromosomes) {

    next if ($_ eq "");

    undef (@coords);
    undef (@introns);

    print "Checking GFF file: 'CHROMOSOME_${chromosome}'\n";

    open (OUT_CAM, ">$gffdir/../CHECKS/CHROMOSOME_${chromosome}.check_intron_cam.gff");
    open (OUT_STL, ">$gffdir/../CHECKS/CHROMOSOME_${chromosome}.check_intron_stl.gff");

    # make a hash for all curated introns

    print "Make a hash for all introns\n";
    open (GFF_in, "/wormsrv2/scripts/gff_sort $gffdir/GFF_SPLITS/CHROMOSOME_${chromosome}.intron.gff |") || die "Failed to open gff file\n\n";
    while (<GFF_in>) {
	chomp;
	s/\#.*//;
	next unless /\S/;
	@f = split /\t/;
	push (@introns,"$f[3] $f[4] $f[8]");
#	print "# $f[3] $f[4] $f[8]\n";
    }	
    close GFF_in;

#    print "Cycle through introns in .gff file\n\n";

    open (GFF, "<$gffdir/../CHROMOSOMES/CHROMOSOME_${chromosome}.gff") || die "Failed to open gff file\n\n";
    while (<GFF>) {
	
	
	chomp;
	s/\#.*//;
	next unless /\S/;
	
	# split the GFF line
	@f = split /\t/;

	# reset match tag
	$match = 0;

	# Store Genomic_canonical coords
	if ($f[1] eq "Genomic_canonical") {
	    my ($clone) = $f[8] =~ /Sequence \"(\S+)\"/;
#	    print "# Clone:\t$clone  \t$f[3] -> $f[4]\n";
	    push (@coords,"$f[3] $f[4] $clone");
	}
	
	# Confirmed_introns not in gene models
	if ( (($f[2] eq "intron") && ($f[1] eq "") && (not $f[8] =~ /Confirmed_in_UTR/) ) || ( ($f[1] eq "NDB_CDS") && (($f[8] =~ /Confirmed_by_EST/) || ($f[8] =~ /Confirmed_by_cDNA/))) ) {
	    

	    
	    $line = $_;
	    


#	    print "Check through known intron coordinates: $f[3] $f[4]\n";
	    
	    foreach $look (@introns) {
		($start,$stop,$seq) = split (/ /, $look);
	#	print "  => $start $stop $seq\n";
		if (($f[3] == $start) && ($f[4] == $stop) ) {
		    # found match
		    $match = 1;
#		    print " !! found match !!\n";
		    last;
		}
	    }

	    unless ($match == 1) {
		
		foreach $look (@coords) {
		    ($start,$stop,$seq) = split (/ /, $look);
		    if ( ($f[3] > $start) && ($f[4] < $stop) ) {
			$obj = $db->fetch(Sequence=>$seq);
			unless (!defined ($obj)) {
			    $lab=$obj->From_Laboratory(1);
			    $obj->DESTROY();
			}
			if ($lab eq "HX") {
#			    print "CAM => $line Clone:$seq Lab:$lab\n";
			    print OUT_CAM "$line Clone:$seq Lab:$lab\n";
			}
			elsif ($lab eq "RW") {
#			    print  "STL => $line Clone:$seq Lab:$lab\n";
			    print OUT_STL "$line Clone:$seq Lab:$lab\n";
			}
			($seq,$lab) = "";
			$confirmed_intron{$chromosome}++;
		    }
		}
	    }

	
	    
	}
	
	# Short cut 
	last if ($f[1] eq "tandem");
	
    }
    close GFF;
    

    print "Completed GFF file: 'CHROMOSOME_${chromosome}' : Confirmed_introns not in GeneModel $confirmed_intron{$chromosome}\n";

}
close OUT_CAM;
close OUT_STL;



exit(0);


sub numerically {
    $a <=> $b;
}

#######################################################################
# Help and error trap outputs                                         #
#######################################################################

sub run_details {
    print "# dbcheck\n";     
    print "# run details    : $rundate $runtime\n";
    print "\n";
}


sub usage {
    my $error = shift;

    if ($error == 1) {
        # No WormBase release number file
        print "The WormBase release number cannot be parsed\n";
        print "Check File: '$Wormbase_release_file'\n\n";
        &run_details;
        exit(0);
    }
    elsif ($error == 0) {
        # Normal help menu
        exec ('perldoc',$0);
        exit (0);
    }
}


__END__

=pod

=head1 NAME - introncheck

=back

=head1 USAGE

=over 4

=item introncheck [-options]

introncheck searches for confirmed introns which aren't part of a gene model yet.

=back

=head2 dbcheck MANDATORY arguments:

=over 4

=item none

=back

=head2 introncheck OPTIONAL arguments:

=over 4

=item -h, Help

=item -d, Debug/Verbose mode

=item -s, check Status tags

=back

=head1 AUTHOR - Daniel Lawson

Email dl1@sanger.ac.uk

=cut







