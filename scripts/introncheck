#!/usr/local/bin/perl5.8.0 -w
#
# introncheck
#
# introncheck searches for confirmed introns which aren't part of a gene model yet
#
# Usage: introncheck [-options]
#
# Last updated by: $Author: dl1 $     
# Last updated on: $Date: 2004-01-30 12:39:56 $      

#################################################################################
# variables                                                                     #
#################################################################################

use Getopt::Std;
use Ace;
use lib -e "/wormsrv2/scripts"  ? "/wormsrv2/scripts"  : $ENV{'CVS_DIR'};
use Wormbase;
use strict;

##############################
# Script variables (run)     #
##############################

my $rundate = `date +%y%m%d`; chomp $rundate;
my $runtime = &runtime;

##############################
# command-line options       #
##############################

our $opt_d="";   # Verbose debug mode
our $opt_h="";   # Help/Usage page

getopts ('hd');
&usage(0) if ($opt_h);
my $debug = $opt_d;

 ##############################
 # Paths etc                  #
 ##############################

my $tace = &tace;    # tace executable path
my $dbdir  = "/wormsrv2/autoace";                                  # Database path
my $gffdir = "/wormsrv2/autoace/GFF_SPLITS";

my @chromosomes = ('I','II','III','IV', 'V','X');
my %confirmed_intron = ();		  


########################################
# Connect with acedb server            #
########################################

my $db = Ace->connect(-path=>$dbdir) || die "Couldn't connect to $dbdir\n";

foreach my $chromosome (@chromosomes) {

  my (@coords, @introns);

  print "Checking GFF file: 'CHROMOSOME_${chromosome}'\n";

  open (OUT_CAM, ">$dbdir/CHECKS/CHROMOSOME_${chromosome}.check_intron_cam.gff");
  open (OUT_STL, ">$dbdir/CHECKS/CHROMOSOME_${chromosome}.check_intron_stl.gff");

  #######################################
  # make a hash for all curated introns #
  #######################################

  print "Make a hash for all introns on chromosome $chromosome\n";
  open (GFF_in, "/wormsrv2/scripts/gff_sort $gffdir/GFF_SPLITS/CHROMOSOME_${chromosome}.intron.gff |") || die "Failed to open gff file in $gffdir/GFF_SPLITS/\n\n";

  while (<GFF_in>) {
    chomp;
    s/\#.*//;
    next unless /\S/;
    my @f = split /\t/;
    push (@introns,"$f[3] $f[4] $f[8]");
  }	
  close GFF_in;


  ###################################################
  # print "Cycle through introns in .gff file\n\n"; #
  ###################################################
  
  open (GFF, "<$dbdir/CHROMOSOMES/CHROMOSOME_${chromosome}.gff") || die "Failed to open gff file in $dbdir/CHROMOSOMES/CHROMOSOME \n\n";

  while (<GFF>) {       	
      chomp;
      s/\#.*//;
      next unless /\S/;
    
      # split the GFF line
      my @f = split /\t/;
      
      # reset match tag
      my $match = 0;
      
      # Store Genomic_canonical coords
      if ($f[1] eq "Genomic_canonical") {
	  my ($clone) = $f[8] =~ /Sequence \"(\S+)\"/;
	  #	    print "# Clone:\t$clone  \t$f[3] -> $f[4]\n";
	  push (@coords,"$f[3] $f[4] $clone");
      }
      
      # Confirmed_introns not in gene models
      
      # ignore some marked introns
      next if ($f[8] =~ /Confirmed_as_false/);                # Bad BLAT mapping
      next if ($f[8] =~ /Confirmed_as_inconsistent/);         # Can't make a valid CDS prediction from this
      
      if ( ( ($f[2] eq "intron") && ($f[1] eq ".") && (not $f[8] =~ /Confirmed_in_UTR/) ) || 
	   ( ($f[2] eq "intron") && ($f[1] eq "Coding_transcript") ) ||
	   ( ($f[1] eq "NDB_CDS") && (($f[8] =~ /Confirmed_by_EST/) || ($f[8] =~ /Confirmed_by_cDNA/) ) ) ) {
	
	  my $line = $_;      
      
	  # print "Check through known intron coordinates: $f[3] $f[4]\n";
      
	  foreach my $look (@introns) {
	      my ($start,$stop,$seq) = split (/ /, $look);
	      #	print "  => $start $stop $seq\n";
	      if (($f[3] == $start) && ($f[4] == $stop) ) {
		  # found match
		  $match = 1;
		  # print " !! found match !!\n";
		  last;
	      }
	  }
      
	  unless ($match == 1){	
	      foreach my $look (@coords) {
		  my ($start,$stop,$seq) = split (/ /, $look);
		  if ( ($f[3] > $start) && ($f[4] < $stop) ) {
		      my $obj = $db->fetch(Sequence=>$seq);
		      my $lab;
		      unless (!defined ($obj)) {
			  $lab=$obj->From_laboratory(1);
			  $obj->DESTROY();
		      }
		      if ($lab eq "HX") {
			  # print "CAM => $line Clone:$seq Lab:$lab\n";
			  print OUT_CAM "$line\tClone:$seq\tLab:$lab\n";
		      }
		      elsif ($lab eq "RW") {
			  #			    print  "STL => $line Clone:$seq Lab:$lab\n";
			  print OUT_STL "$line\tClone:$seq\tLab:$lab\n";
		      }
		      ($seq,$lab) = "";
		      $confirmed_intron{$chromosome}++;
		  }
	      }
	  }  
      }
      
      # Short cut 
      last if ($f[1] eq "tandem");
      
  }
  close GFF;
  
  print "Completed GFF file: 'CHROMOSOME_${chromosome}'\t: Confirmed_introns not in GeneModel $confirmed_intron{$chromosome}\n";
}
close OUT_CAM;
close OUT_STL;

$db->close;
exit(0);

sub numerically {
  my($a, $b);
    $a <=> $b;
}

#######################################################################
# Help and error trap outputs                                         #
#######################################################################

sub run_details {
    print "# dbcheck\n";     
    print "# run details    : $rundate $runtime\n";
    print "\n";
}


sub usage {
    my $error = shift;

    if ($error == 1) {
        # No WormBase release number file
        print "The WormBase release number cannot be parsed\n";
        &run_details;
        exit(0);
    }
    elsif ($error == 0) {
        # Normal help menu
        system ('perldoc',$0);
        exit (0);
    }
}


__END__

=pod

=head1 NAME - introncheck

=back

=head1 USAGE

=over 4

=item introncheck [-options]

introncheck searches for confirmed introns which aren't part of a gene model yet.

=back

=head2 dbcheck MANDATORY arguments:

=over 4

=item none

=back

=head2 introncheck OPTIONAL arguments:

=over 4

=item -h, Help

=item -d, Debug/Verbose mode

=back

=head1 AUTHOR - Daniel Lawson

Email dl1@sanger.ac.uk

=cut
