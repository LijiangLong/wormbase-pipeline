#!/usr/local/bin/perl5.8.0 -w
#
# introncheck
#
# introncheck searches for confirmed introns which aren't part of a gene model yet
#
# Usage: introncheck [-options]
#
# Last updated by: $Author: dl1 $     
# Last updated on: $Date: 2004-01-30 14:30:20 $      

#################################################################################
# variables                                                                     #
#################################################################################

use Getopt::Std;
use Ace;
use lib -e "/wormsrv2/scripts"  ? "/wormsrv2/scripts"  : $ENV{'CVS_DIR'};
use Wormbase;
use Coords_converter;
use strict;

$| = 1;

##############################
# Script variables (run)     #
##############################

my $rundate = `date +%y%m%d`; chomp $rundate;
my $runtime = &runtime;

##############################
# command-line options       #
##############################

our $opt_d="";   # Verbose debug mode
our $opt_h="";   # Help/Usage page

getopts ('hd');
&usage(0) if ($opt_h);
my $debug = $opt_d;

 ##############################
 # Paths etc                  #
 ##############################

my $tace = &tace;    # tace executable path
my $dbdir  = "/wormsrv2/autoace";                                  # Database path
my $gffdir = "/wormsrv2/autoace/GFF_SPLITS";

my @chromosomes = ('I','II','III','IV', 'V','X');
my %confirmed_intron = ();		  


our $coords = Coords_converter->invoke($dbdir);         # invoke coordinate parser



########################################
# Connect with acedb server            #
########################################

my $db = Ace->connect(-path=>$dbdir) || die "Couldn't connect to $dbdir\n";

foreach my $chromosome (@chromosomes) {

  my (@coords, @introns);
  
  print "Checking GFF file: 'CHROMOSOME_${chromosome}'\n";

  open (OUT_CAM, ">$dbdir/CHECKS/CHROMOSOME_${chromosome}.check_intron_cam.gff");
  open (OUT_STL, ">$dbdir/CHECKS/CHROMOSOME_${chromosome}.check_intron_stl.gff");

  #######################################
  # make a hash for all curated introns #
  #######################################

  print "Make a hash for all curated introns on chromosome $chromosome\n";
  open (GFF_in, "/wormsrv2/scripts/gff_sort $gffdir/GFF_SPLITS/CHROMOSOME_${chromosome}.intron.gff |") || die "Failed to open gff file at $gffdir/GFF_SPLITS/CHROMOSOME_${chromosome}.intron.gff\n\n";
  
  while (<GFF_in>) {
    chomp;
    s/\#.*//;
    next unless /\S/;
    my @f = split /\t/;
    push (@introns,"$f[3] $f[4] $f[8]");
  }	
  close GFF_in;


  ###################################################
  # print "Cycle through introns in .gff file\n\n"; #
  ###################################################
  print "Cycle through all introns on chromosome $chromosome\n";
  
  open (GFF, "/wormsrv2/scripts/gff_sort $gffdir/GFF_SPLITS/CHROMOSOME_${chromosome}.intron_all.gff |") || die "Failed to open gff file at $gffdir/GFF_SPLITS/CHROMOSOME_${chromosome}.intron_all.gff \n\n";
  
  while (<GFF>) {       	
    chomp;
    s/\#.*//;
    next unless /\S/;
    
    # split the GFF line
    my @f = split /\t/;
    
    # reset match tag
    my $match = 0;
    my $line = $_;     
  
    # Confirmed_introns not in gene models
    
    # ignore some marked introns
    print "discard as false : $line\n" if ($f[8] =~ /Confirmed_as_false/); 
    next if ($f[8] =~ /Confirmed_as_false/);                # Bad BLAT mapping
    print "discard as inconsistent : $line\n" if ($f[8] =~ /Confirmed_as_inconsistent/); 
    next if ($f[8] =~ /Confirmed_as_inconsistent/);         # Can't make a valid CDS prediction from this

#	 ( ($f[2] eq "intron") && ($f[1] eq "Coding_transcript") ) || 


    if ( ( ($f[2] eq "intron") && ($f[1] eq ".") && (not $f[8] =~ /Confirmed_in_UTR/) ) || 
	 ( ($f[1] eq "NDB_CDS") && (($f[8] =~ /Confirmed_by_EST/) || ($f[8] =~ /Confirmed_by_cDNA/) ) ) ) {

      print "Parse : $line\n";
      
      # print "Check through known intron coordinates: $f[3] $f[4]\n";
      
      foreach my $look (@introns) {
	my ($start,$stop,$seq) = split (/ /, $look);
#	 print "  => $start $stop $seq\n";
	if (($f[3] == $start) && ($f[4] == $stop) ) {
	  # found match
	  $match = 1;
#	   print " !! found match !!\n";
	  last;
	}
      }
      
      unless ($match == 1){	
	
	my @data = $coords->LocateSpan($f[0], $f[3], $f[4]);
	print "Maps to $data[0] from $data[1] - $data[2]\n";

	my $obj = $db->fetch(Sequence=>$data[0]);
	my $lab;
	unless (!defined ($obj)) {
	  $lab=$obj->From_laboratory(1);
	  $obj->DESTROY();
	}
	if ($lab eq "HX") {
	  # print "CAM => $line Clone:$data[0] Lab:$lab\n";
	  print OUT_CAM "$line\tClone:$data[0] $data[1] $data[2]\tLab:$lab\n";
	}
	elsif ($lab eq "RW") {
	  # print  "STL => $line Clone:$data[0] Lab:$lab\n";
	  print OUT_STL "$line\tClone:$data[0] $data[1] $data[2]\tLab:$lab\n";
	}
	$lab = "";
	$confirmed_intron{$chromosome}++;
      }
    # end of parse loop  
    }
    else {
      print "discard : $line\n";
    }

    # Short cut 
    last if ($f[1] eq "tandem");
    
  }
  close GFF;
  
  print "Completed GFF file: 'CHROMOSOME_${chromosome}'\t: Confirmed_introns not in GeneModel $confirmed_intron{$chromosome}\n";
}
close OUT_CAM;
close OUT_STL;

$db->close;
exit(0);

sub numerically {
  my ($a,$b);
  $a <=> $b;
}

#######################################################################
# Help and error trap outputs                                         #
#######################################################################

sub run_details {
    print "# dbcheck\n";     
    print "# run details    : $rundate $runtime\n";
    print "\n";
}


sub usage {
    my $error = shift;

    if ($error == 1) {
        # No WormBase release number file
        print "The WormBase release number cannot be parsed\n";
        &run_details;
        exit(0);
    }
    elsif ($error == 0) {
        # Normal help menu
        system ('perldoc',$0);
        exit (0);
    }
}


__END__

=pod

=head1 NAME - introncheck

=back

=head1 USAGE

=over 4

=item introncheck [-options]

introncheck searches for confirmed introns which aren't part of a gene model yet.

=back

=head2 dbcheck MANDATORY arguments:

=over 4

=item none

=back

=head2 introncheck OPTIONAL arguments:

=over 4

=item -h, Help

=item -d, Debug/Verbose mode

=back

=head1 AUTHOR - Daniel Lawson

Email dl1@sanger.ac.uk

=cut
