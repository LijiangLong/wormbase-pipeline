#!/usr/local/bin/perl
# Script for predictive operon identification. 
# Input: parsed_eleborated files coming from Elaborate_Intersect_Parsed
# Output: table of results
# Version 2, February 2000, ag3

format OUTOPERON =
@<<<<<<<<<<<<<<<<<<<<<  ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
$seqname,               $seqcomment
                        ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~~
                        $seqcomment
.

use Getopt::Std;
$| = 1;
getopts ('i:n:d:');
$tace="/nfs/disk100/acedb/RELEASE.SUPPORTED/bin.ALPHA_4/tace";

if (!$opt_i) {
  $HELP=<<END;
IdentifyOperons_2
Options: 
-i input file from Elaborate_Intersect_Parsed
[-d intergenic delta, i.e. the nt distance between two contiguous genes to be considered as parts of an operon (default is 500)]
[-n minimal number of genes required to define an operon (default is 2) ]
The output file will be input_file.operons.delta, in the form of a table
containing all the annotations in addition to the predicted operons.
END
  print $HELP;
  exit;
}

if (!$opt_n) {
  $thresh = 2;
} else {
  $thresh = $opt_n;
}
if (!$opt_d) {
  $delta = 500;
} else {
  $delta = $opt_d;
}

$opt_i =~ (/^(\w+)\./) && do {$root = $1;};
$operonfile = "$root".".operons."."$delta".".table";

open (INLIST,$opt_i);
$pluscounter=$minuscounter=0;
while ($line=<INLIST>) {
  if ($line =~ /\%\%/) {
    @myfields = split (/\s+/,$line);
    $gene = $myfields[1];
    $start = $myfields[2];
    $end = $myfields[3];
    $strand = $myfields[4];
# Search operons with genes on plus strand
    if ($strand =~/\+/) {
      $pluscounter++;
      &MakePlusOperons($start,$end,$gene,$pluscounter);
    }
# Search operons with genes on minus strand
    if ($strand =~/\-/) {
      $minuscounter++; 
      &MakeMinusOperons($start,$end,$gene,$minuscounter); 
    }
  }
}
close INLIST;

# Dump everything

&OperonDump();

exit;


#------------------------------------
# Create one hash of putative operons
# on PLUS strand
#
sub MakePlusOperons {
 my ($START,$END,$SEQNAME,$COUNTER) = @_ ;
 my $PREVCOORDS = $PLUSSTORAGE[$COUNTER-1];
 @PREV_ARRAY=split(/\s/,$PREVCOORDS);
 next if ($PREV_ARRAY[0] =~ /^ $/);
 $PLUSSTORAGE[$COUNTER] = "$START $END $SEQNAME";
 my $DIFF=$START-$PREV_ARRAY[1];
 next if ($DIFF < 0);
# We choose as operon name the name of the first gene in the sequence.
# An operon is defined as "finished" when the intergenic distance is 
# greater than delta.
 if ($DIFF < $delta) {
     $SEQNAME = "$SEQNAME Diff ^ : $DIFF";
    push (@{$PLUSOPERONS{$PLUSFIRSTGENE}},$SEQNAME); 
 } else {
# Build a new operon hash, and give it the name of the first gene 
  $PLUSFIRSTGENE=$SEQNAME;
  push (@{$PLUSOPERONS{$PLUSFIRSTGENE}},$SEQNAME);
 }
}


#------------------------------------
# Create one hash of putative operons
# on MINUS strand
#
sub MakeMinusOperons {   
 my ($START,$END,$SEQNAME,$COUNTER) = @_ ;
 my $PREVCOORDS = $MINUSSTORAGE[$COUNTER-1];
 @PREV_ARRAY=split(/\s/,$PREVCOORDS);
 next if ($PREV_ARRAY[0] =~ /^ $/);
 $MINUSSTORAGE[$COUNTER] = "$START $END $SEQNAME";
 my $DIFF=$START-$PREV_ARRAY[1];
 next if ($DIFF < 0);
# An operon is defined as "finished" when the intergenic distance is 
# greater than delta.
 if ($DIFF < $delta) {
    $SEQNAME = "$SEQNAME Diff V : $DIFF";
    push (@{$MINUSOPERONS{$MINUSFIRSTGENE}},$SEQNAME); 
 } else {
# Build a new operon hash, and give it the name of the first gene 
   $MINUSFIRSTGENE=$SEQNAME;
   push (@{$MINUSOPERONS{$MINUSFIRSTGENE}},$SEQNAME);
 }
}


#----------------------------------
# Dump operon hashes. An operon is 
# dumped only if it does have a 
# number of genes > threshold
#
sub OperonDump {
 open (OUTOPERON,">$operonfile") or die ("Could not open $operonfile\n");
 foreach $OPRNAME (sort keys %PLUSOPERONS) {
  if (@{$PLUSOPERONS{$OPRNAME}} < $thresh) {
    next;
  } else {
    $PLUSFIRSTGENE = shift (@{$PLUSOPERONS{$OPRNAME}});    
    $seqname = $PLUSFIRSTGENE;
    $remark="[ag3] This gene is the first of a putative operon";
    $seqcomment = &Command($seqname,$remark);
    $seqcomment =~ s/\"//mg;
    chomp $seqcomment;
    write(OUTOPERON);
    foreach (@{$PLUSOPERONS{$OPRNAME}}) {
     $seqname=$_;
     $remark = "[ag3] This gene may be a downstream gene in an operon beginning with $PLUSFIRSTGENE";
     $seqcomment = &Command($seqname,$remark);
     $seqcomment =~ s/\"//mg;
     chomp $seqcomment;
     write (OUTOPERON);
    }
     $seqname = "+\n\n";
     $seqcomment = "\n\n";
     write (OUTOPERON);
     $seqname="\n\n";
     $seqcomment="\n\n";
     write (OUTOPERON);
    }
}

  foreach $OPRNAME (sort keys %MINUSOPERONS) {
    if (@{$MINUSOPERONS{$OPRNAME}} < $thresh) {
      next;
    } else {
# Reverse the hash because the first gene of the operon
# is actually the last, when looking at the minus strand .
      @ORIGOPERONS = @{$MINUSOPERONS{$OPRNAME}};
      @MINUSOPERONS = reverse (@ORIGOPERONS);
      $MINUSFIRSTGENE = shift (@MINUSOPERONS);    
      $seqname = $MINUSFIRSTGENE;
      $remark="[ag3] This gene may be the first of a putative operon";
      $seqcomment = &Command($seqname,$remark);
      $seqcomment =~ s/\"//mg;
      chomp $seqcomment;
      write(OUTOPERON);
      foreach (@MINUSOPERONS) {
	$seqname=$_;
	$remark = "[ag3] This gene may be a downstream gene in an operon beginning with $MINUSFIRSTGENE";
	$seqcomment = &Command($seqname,$remark);
	$seqcomment =~ s/\"//mg;
	chomp $seqcomment;
	write (OUTOPERON);	    
      }
      $seqname = "-\n\n";
      $seqcomment="\n\n";
      write (OUTOPERON);
      $seqname="\n\n";
      $seqcomment="\n\n";
      write (OUTOPERON);
    }
  }
  close OUTOPERON;
}


sub Command {
    my $exec = "$tace /nfs/disk100/wormpub/autoace";
#    my $exec = "$tace /nfs/disk100/wormpub2/ag3/autoaceBCK";  
    my $seqname = shift;
    my $commandarg = shift;
    my $remark="";
    my $command="";
    my $command=<<EOF;
find Sequence $seqname
show -a Visible Remark
EOF
    open(TXTACE, "echo '$command' | $exec |");
    while (<TXTACE>) {
	if ($_ =~ /\/\//) { next; }
	if ($_ =~ /acedb/) { next; }
	if ($_ =~ /Remark\s+/) {
	    $next = $';
	    chomp $next;
	    $remark.= " $next";
	}
    }
    close TXTACE;
    $length = length($remark);
    if ($length==0) {
	$remark = $commandarg;
    } else {
        $commandarg.=" $remark";
	$remark = $commandarg;
    }
    return $remark;
}








