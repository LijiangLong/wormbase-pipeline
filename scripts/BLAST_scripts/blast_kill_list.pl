#!/usr/bin/env perl
#
# blast_kill_list.pl
#
# Last edited by: $Author: gw3 $
# Last edited on: $Date: 2013-03-12 12:23:40 $

if (defined $ENV{'SANGER'}) {
use GDBM_File;
} else {
use DB_File;
}
use lib $ENV{'WORM_PACKAGES'} . '/ensembl/bioperl-live/';
use Digest::CRC qw(crc64_hex);
use Bio::SeqIO;
use Getopt::Long;
use strict;

my %id_hash;
my ($store,$infile,$killfile,$outfile,$debug);
GetOptions(
    'infile=s'   => \$infile,
    'killfile=s' => \$killfile,
    'outfile=s'  => \$outfile,
    'debug'      => \$debug,
    'store:s'    => \$store,
)||die($!);

&prepare_db($killfile);

my $seqio_object = Bio::SeqIO->new(-file => $infile);
my $seqout = Bio::SeqIO->new(-file => ">$outfile",-format => 'Fasta');

while(my $seq=$seqio_object->next_seq){
    if ($id_hash{$seq->display_id} eq uc(crc64_hex($seq->seq))){
        printf "killing %s %s\n", $seq->display_id, $id_hash{$seq->display_id} if $debug;
        next;
    }
    $seqout->write_seq($seq);
}

# create flatfile database to speed up lookups
sub prepare_db{
    my ($file)=@_;
    if (defined $ENV{'SANGER'}) {
      tie %id_hash,'GDBM_File', '/tmp/id_hash',&GDBM_WRCREAT, 0666 or die "cannot open /tmp/id_hash DBM file\n";
    } else {
      tie (%id_hash, 'DB_File', "/tmp/id_hash", O_RDWR|O_CREAT, 0777, $DB_HASH) or die "cannot open /tmp/id_hash DBM file\n";
    }
    open INF, "<$file" || die "cannot open $file\n";
    my $counter=0;
    while (<INF>){
        my @a=split;
        $id_hash{$a[0]}=$a[-1];
        print '.' if (($counter++ % 1000 == 0)&&$debug);
    }
    print "\n" if $debug;
    close INF;
}

# lifted from Renee Baecker
sub _crc64 {
  my ($text) = @_;
  use constant EXP => 0xd8000000;
  my @highCrcTable = 256;
  my @lowCrcTable  = 256;
  my $initialized  = ();
  my $low          = 0;
  my $high         = 0;

  unless($initialized) {
    $initialized = 1;
    for my $i(0..255) {
      my $low_part  = $i;
      my $high_part = 0;
      for my $j(0..7) {
        my $flag = $low_part & 1; # rflag ist f<C3><BC>r alle ungeraden zahlen 1
        $low_part >>= 1;# um ein bit nach rechts verschieben
        $low_part |= (1 << 31) if $high_part & 1; # bitweises oder mit 2147483648 (), wenn $parth ungerade
        $high_part >>= 1; # um ein bit nach rechtsverschieben
        $high_part ^= EXP if $flag;
      }
      $highCrcTable[$i] = $high_part;
      $lowCrcTable[$i]  = $low_part;
    }
  }

  foreach (split '', $text) {
    my $shr = ($high & 0xFF) << 24;
    my $tmph = $high >> 8;
    my $tmpl = ($low >> 8) | $shr;
    my $index = ($low ^ (unpack "C", $_)) & 0xFF;
    $high = $tmph ^ $highCrcTable[$index];
    $low  = $tmpl ^ $lowCrcTable[$index];
  }
  return sprintf("%08X%08X", $high, $low);
}

# cleanup the tempfile
END{
    untie %id_hash;
    unlink '/tmp/id_hash';
}

=pod

=head1 NAME

blast_kill_list.pl

=head1 DESCRIPTION filters a fasta file based on a kill list

The kill list needs to have one line per entry containing the accession number, species and a crc64 checksum of the sequence.

A0B530  "Methanosaeta thermophila;(Methanothrix thermophila;)"  ADBC610B1D5153E4

The kill list can be generated by using blastfilter.pl

=head1 OPTIONS

=head2 -infile FILENAME

a file in FASTA format to be filtered.

=head2 -killfile FILENAME

a file in the above described kill list format

=head2 -outfile FILENAME

outputfile (will be also FASTA format)

=head2 -debug

adds some verbose output about what was killed.

=cut
