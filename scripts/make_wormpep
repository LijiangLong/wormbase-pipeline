#!/usr/local/bin/perl
#
# make_wormpep
# v 4.1
# 
# Usage : make_wormpep -r <release_number>
#
# Builds a wormpep data set from the current autoace database
#

# v1.10  : dl  : use rd tace version as the current one does not contain the dumping 
#                sequences with S_Map tags bug fix

# v4.1
# 010116 : dl  : Use tablemaker call in tace to get data from autoace
#              : Bring runtime down to 30 minutes
# 010124 : dl  : Include CDS with X's in the full release
# 010418 : dl  : Added system call to make patch file from old release
# 010612 : dl  : Moved to RELEASE.SUPPORTED code to circumvent aceperl 4_9 code problem
# 010711 : dl  : Added Kerstin and Keith to maintainer mail list 

# v4.0
# 010116 : dl  : Use tace not AcePerl

# v3.0
# 010110 : dl  : More verbose logging/error trapping

# v2.0
# 001102 : dl  : Moved to new path for wormpep versions

# v1.0
# 990930 : ms2 : original


#################################################################################
# variables                                                                     #
#################################################################################

$| = 1;
#use strict;
use vars qw($opt_r $opt_d $opt_h);
use Getopt::Std;
use IO::Handle;
use Ace;
use Socket;
use lib '/wormsrv2/scripts/';
use Wormbase;

    
 #######################################
 # Script variables (run)              #
 #######################################

my $maintainer = "dl1\@sanger.ac.uk, krb\@sanger.ac.uk, kj2\@sanger.ac.uk";
my $rundate    = `date +%y%m%d`; chomp $rundate;
my $runtime    = `date +%H:%M:%S`; chomp $runtime;
my $version    = get_cvs_version($0);

 #######################################
 # command-line options                #
 #######################################

getopts ('dhr:');

 #######################################
 # sanity checks for the input         #
 #######################################

&error(0) if ($opt_h);
&error(1) if ((length $opt_r) == 0);
&error(2) if (($opt_r =~ /\D+/));

 #######################################
 # release data                        #
 #######################################

my $release = $opt_r; 
my $old_release = $release-1;
my $debug = $opt_d;

 ########################################################################
 # files in wormpep directory
 #   wp.fasta            all sequences ever assigned (wpid and sequence)
 #   wormpep.table       dotname (primary), wpid, locus, brief_id, lab origin
 #   wormpep             current proteins with info from wormpep.table
 #   wormpep.accession   wpid, if active all associated dotnames, if duplicate link to active wpid
 #   wormpep.history     dotname, wpid, start (version Nr.), stop (version Nr.) if inactive
 ########################################################################
 # set variables

my $dbdir = glob "/wormsrv2/autoace";
my $wpdir = glob "/wormsrv2/WORMPEP/wormpep$old_release";
my $new_wpdir = glob "/wormsrv2/WORMPEP/wormpep$release";
my $tace = "/nfs/disk100/acedb/RELEASE.DEVELOPMENT/bin.ALPHA_4/tace";

# tmp version to use to get around Smap/Schild problems
# my $tace = "/nfs/griffin2/rd/acedb/bin.ALPHA_4/tace";

$ENV{'ACEDB'} = $dbdir;


 ########################################
 # Open logfile                         #
 ########################################

my $log="/wormsrv2/logs/make_wormpep.$release.$rundate.$$";
open (LOG,">$log");
LOG->autoflush();

print LOG "# make_wormpep\n";
print LOG "# version        : $version\n";
print LOG "# run details    : $rundate $runtime\n";
print LOG "\n";
print LOG "Wormpep version  : wormpep$opt_r\n\n";
print LOG "=============================================\n";
print LOG "\n";

 ##################################################
 # Make new directory for current release         #
 ##################################################

mkdir ("$new_wpdir" , 0755) || &error(3);               # die "cannot create the $new_wpdir directory\n";

#open (WP_LOG , ">$new_wpdir/wp.log$release") || &error(4); # die "cannot create $new_wpdir/wp.log$release\n" ;
print LOG "# $runtime : making wormpep$release for $rundate\n\n";


 ##################################################
 # read in the wp.fasta file                      #
 # contains all protein sequences ever assigned   #
 # creates:                                       #
 # %seq2num : XREF number to sequence             #
 # @num2seq : sequence for entries                #
 # @num2dot : accession for entries (CE number)   #
 ##################################################

print LOG "# $runtime : initiate parsing of wp.fasta file\n";

my (%seq2num , @num2seq , @num2dot);
undef (my $id) ;
my $wpmax = 0 ;
my $seq = "";
my $duplicates = 0;

open (WP , "$wpdir/wp.fasta$old_release") || &error(5); # die "couldn't open $wpdir/wp.fasta$old_release\n";
while (<WP>) {
    chomp;
    if (/^>(\S+)/) {
        my $new_id = $1;
	if ($id) {
            $id =~ /CE0*([1-9]\d*)/ ; my $num = $1 ;
	    if ($num > $wpmax) {
		$wpmax = $num;
	    }
            $num2seq[$num] = $seq;
            unless (exists ($seq2num{$seq})) { 
                $seq2num{$seq} = $num;
                $num2dot[$num] = $id;
            } else {
                ++$duplicates;
                my $old_id = $seq2num{$seq};
                my $old_id_pad = sprintf "%05d" , $old_id;
                $num2dot[$num] = "$id -> CE$old_id_pad";
	    }
	}
	$id = $new_id ; $seq = "" ;
    } elsif (eof) {
        if ($id) {
            $id =~ /CE0*([1-9]\d*)/ ; my $num = $1 ;
	    if ($num > $wpmax) {
		$wpmax = $num;
	    }
            $seq .= $_ ;
            $num2seq[$num] = $seq;
            unless (exists ($seq2num{$seq})) { 
                $seq2num{$seq} = $num;
                $num2dot[$num] = $id;
            } else {
                ++$duplicates;
                my $old_id = $seq2num{$seq};
                my $old_id_pad = sprintf "%05d" , $old_id;
                $num2dot[$num] = "$id -> CE$old_id_pad";
	    }
        }
    } else {
	$seq .= $_ ;
    }
}

my $old_wpmax = $wpmax;

my $runtime = `date +%H:%M:%S`; chomp $runtime;
print LOG "=> wp.fasta file contains $duplicates duplicate sequences\n";
print LOG "=> wpmax of wp.fasta$old_release equals $old_wpmax\n";
print LOG "# $runtime : completed parsing of wp.fasta file\n\n";
close WP;

 ###############################################
 # retrieve the desired sequence objects (CDS) #
 ###############################################

my $runtime = `date +%H:%M:%S`; chomp $runtime;
print LOG "# $runtime : connect to primary database\n";

my $db = Ace->connect (-path => $dbdir, -program => $tace) 
    || &error(6); # die "cannot connect to autoace\n";
my @dotnames_1 = $db->fetch (-query => 'FIND Genome_sequence ; FOLLOW Subsequence ; where (Method = curated) OR (Method=provisional)');
my @dotnames_2 = $db->fetch (-query => 'FIND Sequence *LINK* ; FOLLOW Subsequence ; where (Method = curated) OR (Method=provisional)');

push (@dotnames_1 , @dotnames_2);
@dotnames_1 = sort @dotnames_1;

my $runtime = `date +%H:%M:%S`; chomp $runtime;
print LOG "=> " . scalar(@dotnames_1) . " CDS sequences\n";
print LOG "=> " . scalar(@dotnames_2) . " of which are attached to LINK objects\n";
print LOG "# $runtime : finished connection to database\n\n";

 ###########################################################################
 # get the dna and peptide sequence, write a dna.fasta file,
 # and map the peptide sequences onto wormpep, deleting Peptides containing an X or a *,
 # and giving a new wpid if necessary, creating %dot2num
 ###########################################################################
 
my $runtime = `date +%H:%M:%S`; chomp $runtime;
print LOG "# $runtime : write wormpep.dna file\n\n";

my $obj = "";

open (DNA , ">$new_wpdir/wormpep.dna$release") || &error(7); # die "cannot create $new_wpdir/wormpep.dna$release\n";
my (%dot2num , @dotnames , @c_dotnames);
foreach my $dot (@dotnames_1) {
    
    
    if ($dot =~ /temp/) {
       print LOG "$dot is only a temporary sequence\n";
       next;
    }
    unless (($dot =~ /^[A-Z0-9]+\.[1-9]\d?[A-Za-z]?$/) || ($dot =~ /^[A-Z0-9]+\.[A-Za-z]{1,2}$/)) {
        print LOG "the sequence $dot has an incorrect dotname\n";
    }
    undef (my $dna);
    undef (my $method);


##    $method = $dot -> at ('Method.[1]');
##    if ($method !~ /curated/) {
##	print LOG "the sequence $dot has NON-CURATED method $method\n";
##	next;
##    }

    $obj = $db->fetch(Sequence=>"$dot");
    
#    $est_match = $obj->Matching_cDNA();
#    if (defined ($est_match))  {
#	$est{$dot} = 1;
#    }
#    else {
#	$est{$dot} = 0;
#    }

    $dna = $obj->asDNA();
    if ((!defined ($dna)) || ($dna eq "")) {
        print LOG "cannot extract dna sequence for $dot\n";
    }
    $dna =~ /^>(\S+)\s+(\w.*)/s ; my $dseq = $2 ; $dseq =~ tr/a-z/A-Z/ ; $dseq =~ s/\s//g;
    if ($dseq =~ /[^ACGT]/) {
	if ($dseq =~ /\-/) {                                  # - seems to indicate that e.g the subsequence
	    print LOG "the dna sequence $dot contains a -\n"; # coordinates differ from the last exon coordinate
	} elsif ($dseq =~ /N/) {
            print LOG "the dna sequence $dot contains a N\n";
	  } else {                         
	      print LOG "the dna sequence $dot contains a non ACGT character different from - and N\n";  
	    }
    }
    print DNA "$dna";
    undef (my $pep);
    $pep = $obj->asPeptide();
    if ((!defined ($pep)) || ($pep eq "")) {
       print LOG "cannot extract peptide sequence for $dot\n";
       next;
    }
    $pep =~ /^>(\S+)\s+([\w\*].*)/s ; my $pseq = $2 ; $pseq =~ tr/a-z/A-Z/ ; $pseq =~ s/\s//g;


#    removed 011210 so that we see these errors in the log
#    if (($pseq =~ /X/) && ($dot ne "M106\.2") && ($dot ne "B0303\.7") && ($dot ne "B0303\.8") && ($dot ne "M04F3\.2")) {

    if ($pseq =~ /X/) {
	print LOG "the peptide sequence $dot contains an X\n";             
    #       next;                                       
    # 010124 : dl  : CDS with 'X's will be included in the wormpep release
                                                    




                                                               # perhaps I should check if $pname=$1
    }                                                          # equals $dot in all cases
    if ($pseq =~ /\*/) {
       print LOG "the peptide sequence $dot contains a *\n";              
       next;
    }
    unless ($pseq =~ /^M/) {
       print LOG "the peptide sequence $dot does not start with a M\n";
    } 
    my $c_dot = $dot;
    $c_dot =~ tr/a-z/A-Z/;
    unless (exists ($seq2num{$pseq})) {
        $num2seq[++$wpmax] = $pseq;
        $seq2num{$pseq} = $wpmax;
        $dot2num{$c_dot} = $wpmax;
        my $pad = sprintf "%05d" , $wpmax;
        $num2dot[$wpmax] = "CE$pad\t$c_dot";
    } else {
        $dot2num{$c_dot} = $seq2num{$pseq};
        my $num = $seq2num{$pseq};
        $num2dot[$num] .= "\t$c_dot";
      }             
    push (@dotnames , $dot);
    push (@c_dotnames , $c_dot);

    $obj->DESTROY();

}   

close DNA;
chmod (0444 , "$new_wpdir/wormpep.dna$release") || print LOG "cannot chmod $new_wpdir/dotnames.dna$release\n";

my $runtime = `date +%H:%M:%S`; chomp $runtime;
print LOG "# $runtime : finished writing wormpep.dna file\n\n";

 ############################################################################
 # write the new wp.fasta file, and wrap the sequences using rd's seqpress  #
 ############################################################################

my $runtime = `date +%H:%M:%S`; chomp $runtime;
print LOG "# $runtime : writing wormpep.fasta file\n\n";

open (WPFASTA , ">$new_wpdir/wp.fasta_unwrap$release");
for (my $i = 1 ; $i <= $wpmax ; $i++) {
    if (defined ($num2seq[$i])) {
       my $i_pad = sprintf "%05d" , $i;
       print WPFASTA ">CE$i_pad\n$num2seq[$i]\n";
    }
}
close WPFASTA;

system ("/nfs/disk100/wormpub/bin.ALPHA/seqpress -a $new_wpdir/wp.fasta_unwrap$release > $new_wpdir/wp.fasta$release");
chmod (0444 , "$new_wpdir/wp.fasta$release") || print LOG "cannot chmod $new_wpdir/wp.fasta$release\n";

my $runtime = `date +%H:%M:%S`; chomp $runtime;
print LOG "\n# $runtime : finished writing wormpep.fasta file\n\n";

###########################################################################
# retrieve the protein_id and the SWISS-PROT or SPTREMBL accession using srs
# socketsrs: query srs with socket to retrieve large data sets.
# The actual SRS query is
# [libs={embl emblnew}-Organism: Caenorhabditis elegans]
# & ([libs-FtQualifier: gene] > parent) & [libs-AllText: cosmid]
# ag3 271099, modified ms2 991029

my $runtime = `date +%H:%M:%S`; chomp $runtime;
print LOG "# $runtime : retrieve protein_id & accession for each CDS\n";

my $querycontent="%5Blibs%3D%7Bembl_SP_emblnew%7D-Organism%3A%22Caenorhabditis%20elegans%22%5D%26%28%5Blibs-FtQualifier%3Agene%5D%3Eparent%29%26%5Blibs-AllText%3Acosmid%5D+-f+div+-f+key+-f+org+-f+prd+-f+ftd+-f+ftl+-f+date";
my $request = "/srs6bin/cgi-bin/wgetz?$querycontent";

# The EBI server is well hidden under something weird |-(
# Let's use HGMP for the moment
# Use the Sanger one [dl]

my $server = "www.sanger.ac.uk";
if (!defined(open_TCP(*F,$server,80))) {
	print "Error connecting to server at \n";
	exit(-1);
	}
print F "GET $request HTTP/1.0\n\n";
print F "Accept: */*\n";
print F "User-Agent: socketsrs/1.0\n\n";



my $GENE ; my $GENE_1 ; my $SPT ; my $SWISS;
my %SPTREMBL ; my %SWISS_PROT ; my %PROTEIN;

# Parsing annotation


my $genes_parsed=0;

while (my $return_line=<F>) {
  if ($return_line =~ /ID\s+(\w+)/) {
     undef $GENE;
     undef $GENE_1;
     undef $SPT;
     undef $SWISS;
  }
  if ($return_line =~ /CDS/) {
     undef $GENE;
     undef $GENE_1;
     undef $SPT;
     undef $SWISS; 
  }
  if ($return_line =~ /db_xref=\"SPTREMBL\:(\w+)/) {
      $SPT = $1;
  }      
  if ($return_line =~ /db_xref=\"SWISS-PROT\:(\w+)/) {
      $SWISS = $1;
  }
  if ($return_line =~ /note=\"(\w+\.\w+)\;/) {
    $GENE_1=$1;
  }
  if ($return_line =~ /gene=/) {
    $GENE=$';
    chomp $GENE;
    $GENE=~s/\"//g;
    $GENE=~s/\s+//g; 
    
    if ($GENE =~ /^[A-Z0-9]+\.t[1-9]/) {   # get rid of tRNA's!!
        next;
    }
    if ($GENE =~ /\-/) {   # in some cases the gene tag contains the locus name, gene is in note tag!!
       $GENE = $GENE_1; 
    }

    $genes_parsed++;
    
    $SPTREMBL{$GENE} = $SPT;
    $SWISS_PROT{$GENE} = $SWISS;
 
 }
  if ($return_line =~ /protein_id=/) {
     my $PROTEIN=$';
     chomp $PROTEIN;
     $PROTEIN=~s/\"//g;
     $PROTEIN=~s/\s+//g;
     $PROTEIN{$GENE}=$PROTEIN;
  }
}
close F;

my $runtime = `date +%H:%M:%S`; chomp $runtime;
print LOG "=> parsed $genes_parsed CDS\n";
print LOG "# $runtime : finished retrieving protein_id & accession for each CDS\n\n";

 ########################################################
 # Output: successful network connection in file handle #
 ########################################################

sub open_TCP 
{
	my ($FS,$dest,$port) = @_;
	my $proto = getprotobyname ('tcp');
	socket ($FS,PF_INET,SOCK_STREAM,$proto);
	my $sin = sockaddr_in($port,inet_aton($dest));
	connect($FS,$sin) || return undef;
	my $old_fh = select($FS);
        $| = 1;
	select($old_fh);

}


 ########### 
 # most of the data 
 #
 #####

my $runtime = `date +%H:%M:%S`; chomp $runtime;
print LOG "# $runtime : retrieving data from autoace for each CDS\n\n";


my %CDS_locus      = ""; 
my %CDS_id         = ""; 
my %CDS_source     = ""; 
my %CDS_lab        = "";
my %laboratory     = "";
my %CDS_status     = "";
my @CDS            = "";
my %EST            = "";


$ENV{'ACEDB'} = $dbdir;
$command=<<EOF;
Table-maker -p "$dbdir/wquery/wormpep.def"
quit
EOF
    
open (TACE, "echo '$command' | $tace | ");
while (<TACE>) {
    chomp;
    next if ($_ eq "");
    next if (/acedb\>/);
    next if (/\/\//);
    s/\"//g;
    (/^(\S+)\s/);
    ($cds,$parent,$loci,$brief_id,$confirmed,$est) = split /\t/;
    $CDS_locus{$cds} = $loci;
    $CDS_id{$cds} = $brief_id;
    $CDS_lab{$cds} = $parent;
    $EST{$cds} = $est;
    
    # confirmed CDS - [EST|mRNA] data
    if ($confirmed) {
	$CDS_status{$cds} = "Confirmed";
    }
    else {
	# supported CDS - [EST] data
	if ($est > 0) {
	    $CDS_status{$cds} = "Partially_confirmed";
	}
	# predicted CDS - no data
	else {
	    $CDS_status{$cds} = "Predicted";
	}
    }
}
close TACE;

$command1=<<EOF;
Table-maker -p "$dbdir/wquery/wormpep2.def"
quit
EOF
    
open (TACE, "echo '$command1' | $tace | ");
while (<TACE>) {
    chomp;
    next if ($_ eq "");
    next if (/acedb\>/);
    next if (/\/\//);
    s/\"//g;
    ($clone,$lab) = (/^(\S+)\s(\S+)$/);
    $laboratory{$clone} = $lab;
}
close TACE;

my $runtime = `date +%H:%M:%S`; chomp $runtime;
print LOG "# $runtime : finished retrieving data from autoace for each CDS\n\n";



 ###########################################################################
 # get from autoace the data required to write the wormpep file and the wormpep.table file
 # use rd's seqpress to wrap the sequence lines in the wormpep file 
 ###########################################################################

my $runtime = `date +%H:%M:%S`; chomp $runtime;
print LOG "# $runtime : Build wormpep & wormpep.table files\n\n";

open (USERFASTA , ">$new_wpdir/wormpep_unwrap$release") || die "cannot create wormpep_unwrap$release\n";
open (USERTABLE , ">$new_wpdir/wormpep.table$release")  || die "cannot create wormpep.table$release\n";
USERFASTA->autoflush();
USERTABLE->autoflush();

foreach (@dotnames) {
    undef (my $locus_1);
    undef (my $locus);
    undef (my $brief_id);
    undef (my $cosmid);
#    undef (my $lab);

    my $cds = $_;
    my $c_dot = $cds;
    $c_dot =~ tr/a-z/A-Z/;
    my $wpid = $dot2num{$c_dot};
    my $wpid_pad = sprintf "%05d" , $wpid;
    my $pepseq = $num2seq[$wpid];

    if ($CDS_locus{$cds} ne "") {$locus_1 = "locus\:".$CDS_locus{$cds};}
            
#    if ($laboratory{$CDS_lab{$cds}} eq "RW") {$lab = "ST.LOUIS";}
#    if ($laboratory{$CDS_lab{$cds}} eq "HX") {$lab = "HINXTON";}
    
#    my $runtime = `date +%H:%M:%S`; chomp $runtime;
#    print LOG "writing gene $c_dot @ $runtime\n";
    
    if ((defined ($PROTEIN{$cds})) && ($PROTEIN{$cds} ne "")) {
	if ((defined ($SWISS_PROT{$cds})) && ($SWISS_PROT{$cds} ne "")) {
	    print USERFASTA ">$c_dot CE$wpid_pad  $locus_1 $CDS_id{$cds} status\:$CDS_status{$cds} SW\:$SWISS_PROT{$cds} protein_id\:$PROTEIN{$cds}\n$pepseq\n";
	    print USERTABLE "$c_dot\tCE$wpid_pad\t$CDS_locus{$cds}\t$CDS_id{$cds}\t$CDS_status{$cds}\tSW\:$SWISS_PROT{$cds}\t$PROTEIN{$cds}\n";
	} else {
	    if ((defined ($SPTREMBL{$cds})) && ($SPTREMBL{$cds} ne "")) {
		print USERFASTA ">$c_dot CE$wpid_pad  $locus_1 $CDS_id{$cds} status\:$CDS_status{$cds} TR\:$SPTREMBL{$cds} protein_id\:$PROTEIN{$cds}\n$pepseq\n";
		print USERTABLE "$c_dot\tCE$wpid_pad\t$CDS_locus{$cds}\t$CDS_id{$cds}\t$CDS_status{$cds}\tTR\:$SPTREMBL{$cds}\t$PROTEIN{$cds}\n";
	    } else {
                print USERFASTA ">$c_dot CE$wpid_pad  $locus_1 $CDS_id{$cds} status\:$CDS_status{$cds} protein_id\:$PROTEIN{$cds}\n$pepseq\n";
                print USERTABLE "$c_dot\tCE$wpid_pad\t$CDS_locus{$cds}\t$CDS_id{$cds}\t$CDS_status{$cds}\t$PROTEIN{$cds}\n";
	    }
	}
    } else {
	if ((defined ($SWISS_PROT{$cds})) && ($SWISS_PROT{$cds} ne "")) {
	    print USERFASTA     ">$c_dot CE$wpid_pad  $locus_1 $CDS_id{$cds} status\:$CDS_status{$cds} SW\:$SWISS_PROT{$cds}\n$pepseq\n";
	    print USERTABLE      "$c_dot\tCE$wpid_pad\t$CDS_locus{$cds}\t$CDS_id{$cds}\t$CDS_status{$cds}\tSW\:$SWISS_PROT{$cds}\n";
	} else {
	    if ((defined ($SPTREMBL{$cds})) && ($SPTREMBL{$cds} ne "")) {
		print USERFASTA ">$c_dot CE$wpid_pad  $locus_1 $CDS_id{$cds} status\:$CDS_status{$cds} TR\:$SPTREMBL{$cds}\n$pepseq\n";
		print USERTABLE  "$c_dot\tCE$wpid_pad\t$CDS_locus{$cds}\t$CDS_id{$cds}\t$CDS_status{$cds}\tTR\:$SPTREMBL{$cds}\n";
	    } else {
                print USERFASTA ">$c_dot CE$wpid_pad  $locus_1 $CDS_id{$cds} status\:$CDS_status{$cds}\n$pepseq\n";
                print USERTABLE  "$c_dot\tCE$wpid_pad\t$CDS_locus{$cds}\t$CDS_id{$cds}\t$CDS_status{$cds}\n";
	    }
	}          
    }
} # end of loop foreach (@dotnames)

close USERFASTA;
close USERTABLE;

system ("/nfs/disk100/wormpub/bin.ALPHA/seqpress -a $new_wpdir/wormpep_unwrap$release > $new_wpdir/wormpep$release");
chmod (0444 , "$new_wpdir/wormpep$release") || print LOG "cannot chmod $new_wpdir/wormpep$release\n";
chmod (0444 , "$new_wpdir/wormpep.table$release") || print LOG "cannot chmod $new_wpdir/wormpep.table$release\n";

my $runtime = `date +%H:%M:%S`; chomp $runtime;
print LOG "# $runtime : Finished building wormpep & wormpep.table files\n\n";

###########################################################################
# create a blast'able database (indexing) using setdb for Wublast (not formatdb, which is  for blastall)

system ("cp $new_wpdir/wormpep$release $new_wpdir/wormpep_current");
system ("/usr/local/pubseq/bin/setdb $new_wpdir/wormpep_current > $new_wpdir/wormpep_current.log");

###########################################################################
# count the CDS (with and without alternate splice forms) based on the wormpep file

my @end_dotnames;
open (FILE , "$new_wpdir/wormpep$release") || print LOG  "cannot open the wormpep$release file\n";
while (<FILE>) {
    if (/^\>(\S+)\s+\S+/) {
       my $dot = $1;
       push (@end_dotnames , $dot);
    }
}
close FILE;
my $number_cds = 0;
my $number_total = 0;
my $number_alternate = 0;
my %new_name2x;
foreach (@end_dotnames) {
    $number_total++;
    tr/a-z/A-Z/;
    /^([A-Z0-9]+)\.(.*)$/;
    my $cosmid = $1;
    my $dot = $2;
    if ($dot =~ /^[1-9][0-9]?$/) {
        $number_cds++;
    } elsif ($dot =~ /^[A-Z][A-Z]?$/) {
         $number_cds++;
    } elsif ($dot =~ /(^[1-9][0-9]?)([A-Z])/) {
        my $number = $1;
	my $letter = $2;
        my $new_name = $cosmid."_".$number;
        unless (exists ($new_name2x{$new_name})) {
	    $number_cds++;
        } else {
	    $number_alternate++;
          }
        $new_name2x{$new_name} = "x";
    } else {
        print LOG "$_ has a non\-acceptable name in wormpep$release \(has not been counted\)\n";
        next;
    }
}
print LOG "\n\nthere are $number_cds CDS in autoace, $number_total when counting \($number_alternate\) alternate splice_forms\n";

###########################################################################
# create the new wormpep.accession,
# wp.table contains tab-separated:  wpid, list of associated dotnames if active, 
# empty if inactive, and link to active wpid in case of duplicate sequences in wp.fasta

open (WPTABLE , ">$new_wpdir/wormpep.accession$release") || die "cannot create wormpep.accession$release\n";

for (my $i = 1 ; $i <= $wpmax ; $i++) {
    if (defined ($num2dot[$i])) {
           print WPTABLE "$num2dot[$i]\n";
    }
}

close WPTABLE;

chmod (0444 , "$new_wpdir/wormpep.accession$release") || print LOG "cannot chmod $new_wpdir/wormpep.accession$release\n";

############################################################################
# read in the current wormpep.history file, update it, and read it back out,
# wormpep.history contains tab-separated:  dotname, wpid, start (release), end (release)

open (OLDHISTORY , "$wpdir/wormpep.history$old_release") || die "cannot open $wpdir/wormpep.history$old_release\n";
open (HISTORY , ">$new_wpdir/wormpep.history$release") || die " cannot create $wpdir/wormpep.history$release\n";
open (DIFF , ">$new_wpdir/wormpep.diff$release") || die " cannot create $wpdir/wormpep.diff$release\n";

my %line;
while (my $line = <OLDHISTORY>) {
    chomp $line;
    my $dotname = ""; my $wpid = ""; my $start = ""; my $end = "";
    ($dotname , $wpid , $start , $end) = split (/\t/ , $line);
    my $c_dot = $dotname;
    $c_dot =~ tr/a-z/A-Z/;
    $wpid =~ /CE0*([1-9]\d*)/ ; my $num = $1;
    $line{$c_dot} = $line;
    if ((!exists ($dot2num{$c_dot}) && ($end eq ""))) {
       print HISTORY "$c_dot\t$wpid\t$start\t$release\n";
       print DIFF "lost:\t$c_dot\t$wpid\n";
   } elsif (($dot2num{$c_dot} ne $num) && ($end eq "")) {
        print HISTORY "$c_dot\t$wpid\t$start\t$release\n";
        my $new_num = $dot2num{$c_dot};
        my $new_pad = sprintf "%05d" , $new_num;
        print HISTORY "$c_dot\tCE$new_pad\t$release\t$end\n";
        print DIFF "changed:\t$c_dot\t$wpid --> CE$new_pad\n";
     } else {
         print HISTORY "$c_dot\t$wpid\t$start\t$end\n";
       }
}

foreach (keys (%dot2num)) {
    my $empty = "";
    my $c_dot = $_;
    $c_dot =~ tr/a-z/A-Z/;
    if (!exists ($line{$c_dot})) {
        my $num = $dot2num{$c_dot};
        my $pad = sprintf "%05d" , $num;
        print HISTORY "$c_dot\tCE$pad\t$release\t$empty\n";
        print DIFF "new:\t$c_dot\tCE$pad\n";
        next;
    }
    my $dotname = ""; my $wpid = ""; my $start = ""; my $end = "";
    ($dotname , $wpid , $start , $end) = split (/\t/ , $line{$c_dot});
    if ($end ne "") {   
        my $new_num = $dot2num{$c_dot};
        my $new_pad = sprintf "%05d" , $new_num;
        print HISTORY "$c_dot\tCE$new_pad\t$release\t$empty\n";
        print DIFF "reappeared:\t$c_dot\tCE$new_pad\n";
    }
}


close OLDHISTORY;
close HISTORY;
close DIFF;
chmod (0444 , "$new_wpdir/wormpep.history$release") || print LOG "cannot chmod $new_wpdir/wormpep.history$release\n";
chmod (0444 , "$new_wpdir/wormpep.diff$release")    || print LOG "cannot chmod $new_wpdir/wormpep.diff$release\n";
my $wpdiff = $wpmax - $old_wpmax;
print LOG "\n\nnew wpmax of wp.fasta$release equals $wpmax\n$wpdiff new sequences have been added\n";


 ####################################################
 # make patch file for changes from last release    #
 ####################################################

print LOG "make patch file for changes since wormpep${old_release}\n";
system ("patch_wormpep -r $release > $new_wpdir/patch_wormpep.${release}-${old_release}.ace");
print LOG "patch file made...\n\n";

 ##############################
 # mail $maintainer report    #
 ##############################

#chmod (0444 , "$new_wpdir/wp.log$release")    || print LOG "cannot chmod $new_wpdir/wp.log$release\n";
unlink ("$new_wpdir/wp.fasta_unwrap$release") || print LOG "cannot delete $new_wpdir/wp.fasta_unwrap$release\n";
unlink ("$new_wpdir/wormpep_unwrap$release")  || print LOG "cannot delete $new_wpdir/wormpep_unwrap$release\n";


#####################################################################
# copy files to ~wormpub/WORMPEP so that wormpep webpage scripts work
#####################################################################

my $wormpub_dir = "/nfs/disk100/wormpub/WORMPEP";

print LOG "Removing old files in $wormpub_dir\n";

unlink("$wormpub_dir/wormpep_current") || print LOG "Cannot delete files in $wormpub_dir\n";
unlink("$wormpub_dir/wormpep.accession_current") || print LOG "Cannot delete files in $wormpub_dir\n";
unlink("$wormpub_dir/wormpep.dna_current") || print LOG "Cannot delete files in $wormpub_dir\n";
unlink("$wormpub_dir/wormpep.history_current") || print LOG "Cannot delete files in $wormpub_dir\n";
unlink("$wormpub_dir/wp.fasta_current") || print LOG "Cannot delete files in $wormpub_dir\n";

print LOG "Copying new files to $wormpub_dir\n";

system ("cp $new_wpdir/wormpep_current $wormpub_dir/wormpep_current")                     || print LOG "Cannot copy file to $wormpub_dir\n";
system ("cp $new_wpdir/wormpep.accession$release $wormpub_dir/wormpep.accession_current") || print LOG "Cannot copy file to $wormpub_dir\n";
system ("cp $new_wpdir/wormpep.dna$release $wormpub_dir/wormpep.dna_current")             || print LOG "Cannot copy file to $wormpub_dir\n";
system ("cp $new_wpdir/wormpep.history$release $wormpub_dir/wormpep.history_current")     || print LOG "Cannot copy file to $wormpub_dir\n";
system ("cp $new_wpdir/wp.fasta$release $wormpub_dir/wp.fasta_current")                   || print LOG "Cannot copy file to $wormpub_dir\n";
system ("/usr/local/pubseq/bin/setdb $wormpub_dir/wormpep_current")                       || print LOG "Cannot index wormpep file in $wormpub_dir\n";

close LOG;

open (mailLOG, "|/usr/bin/mailx -s \"WormBase Report: make_wormpep\" $maintainer ");
open (readLOG, "<$log");
while (<readLOG>) {
    print mailLOG $_;
}
close readLOG;
close mailLOG;

 ##############################
 # hasta luego                #
 ##############################

exit(0);

#################################################################################
# Subroutines                                                                   #
#################################################################################

 ##########################
 # run details            #
 ##########################

sub run_details {
    print "# make_wormpep\n";
    print "# version        : $version\n";
    print "# run details    : $rundate $runtime\n";
    print "\n";
    print "Wormpep version  : wormpep$opt_r\n";
    print "Primary database : $dbdir\n\n";

    if ($opt_d) {
	print "Usage : make_wormpep [-options]\n";
	print "=============================================\n";
	print " -r <int>     : release version number\n";
	print " -h           : help pages   \n";
	print " -d           : verbose (debug) mode\n";
	print "=============================================\n";
	print "\n";
    }
} # end of sub 'run details'

 ##########################
 # errors from the script #
 ##########################

sub error {
    my $error = shift;
    # Error 0 - help page
    if ($error == 0) {
        exec ('perldoc',$0);
        exit (0);
    }
    # Error  1 - no wormpep release number
    elsif ($error == 1) {
        # No wormpep release number file
	&run_details;
        print "=> No wormpep release number supplied\n\n";
        exit(0);
    }
    # Error  2 - invalid wormpep release number
    elsif ($error == 2) {
        # Invalid wormpep release number file
        &run_details;
        print "=> Invalid wormpep release number supplied.\n=> Release number must be an interger (e.g. 30)\n\n";
	exit(0);
    }
    # Error  3 - cannot create new wormpep directory 
    elsif ($error == 3) {
        &run_details;
	print "=> Failed to create a new directory for wormpep release wormpep$release\n\n";
        $runtime = `date +%H:%M:%S`; chomp $runtime;
	print LOG "=> Failed to create a new directory for wormpep release wormpep$release\n\n";
	print LOG "=> Exiting at $rundate $runtime\n";
        close LOG;
        &mail_maintainer("WormBase Report: make_wormpep",$maintainer,$log);
    }
    # Error  4 - cannot open new wp.log file 
    elsif ($error == 4) {
        &run_details;
        print "=> Failed to create a new wp.log for wormpep release wormpep$release\n\n";
        $runtime = `date +%H:%M:%S`; chomp $runtime;
        print LOG "=> Exiting at $rundate $runtime\n";
        close LOG;
        &mail_maintainer("WormBase Report: make_wormpep",$maintainer,$log);
    }
    # Error  5 - cannot open old wp.fasta file 
    elsif ($error == 5) {
        &run_details;
        print "=> Failed to open the old wp.fasta for wormpep release wormpep$old_release\n\n";
        $runtime = `date +%H:%M:%S`; chomp $runtime;
        print LOG "=> Exiting at $rundate $runtime\n";
        close LOG;
        &mail_maintainer("WormBase Report: make_wormpep",$maintainer,$log);
    }
    # Error  6 - cannot connect to ACEDB database 
    elsif ($error == 6) {
        &run_details;
        print "=> Failed to connect to primary database 'dbdir'\n\n";
        $runtime = `date +%H:%M:%S`; chomp $runtime;
        print LOG "=> Exiting at $rundate $runtime\n";
        close LOG;
        &mail_maintainer("WormBase Report: make_wormpep",$maintainer,$log);
    }
    # Error  7 - cannot open new wp.log file 
    elsif ($error == 7) {
        &run_details;
        print "=> Failed to create a new wormpep.dna for wormpep release wormpep$release\n\n";
        $runtime = `date +%H:%M:%S`; chomp $runtime;
        print LOG "=> Exiting at $rundate $runtime\n";
        close LOG;
        &mail_maintainer("WormBase Report: make_wormpep",$maintainer,$log);
    }

    exit(1);
} # end of sub 'error'



__END__

=pod

=head2   NAME - make_wormpep


=head1 USAGE

=over 4

=item make_wormpep [-options]

=back

make_wormpep will generate a peptide data set from the autoace
database directory.

autoace_minder mandatory arguments:

=over 4

=item -r, release number

=back

autoace_minder OPTIONAL arguments:

=over 4

=item -h, Help page

=item -d, Verbose/Debug mode

=back

=head1 EXAMPLES:

=over 4

=item make_wormpep -r 40

=back

Creates a new wormpep data set in the (new) /wormsrv2/WORMPEP/wormpep40 directory

=cut




















